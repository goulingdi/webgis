<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>空中丝路高分中心</title>
    <!-- 1. 引入Leaflet的CSS样式文件 -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        crossorigin=""/>
    <!-- 引入Leaflet绘制插件CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <!-- 为地图容器定义基本样式 -->
    <style>
        /* 全局样式 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f7fa;
            color: #333;
        }
        
        /* 标题样式 */
        h1 {
            text-align: center;
            margin: 40px 0 30px;
            color: #2c3e50;
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        /* 地图容器样式 */
        #map {
            height: 70vh;
            width: 90%;
            max-width: 1200px;
            margin: 0 auto 40px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        #map:hover {
            box-shadow: 0 12px 48px rgba(0, 0, 0, 0.15);
        }
        
        /* 自定义图层切换控件样式 */
        .leaflet-control-layers-toggle {
            width: auto !important;
            height: auto !important;
            padding: 8px 16px !important;
            line-height: 1.6 !important;
            background-color: white !important;
            background-image: none !important;
            text-align: center;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
            border: none !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            color: #3498db !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
        }
        
        .leaflet-control-layers-toggle::after {
            content: "图层切换";
            color: #3498db;
            font-size: 14px;
            font-weight: 500;
        }
        
        .leaflet-control-layers-toggle:hover {
            background-color: #f8f9fa !important;
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15) !important;
        }
        
        /* 图层控制面板样式 */
        .leaflet-control-layers {
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
            background-color: white !important;
        }
        
        /* 测量控制面板样式 */
        .measure-control {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: none;
        }
        
        /* 按钮统一样式 */
        .measure-btn, .clear-btn {
            border: none;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            font-weight: 500;
            margin: 4px 6px 4px 0;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
        }
        
        /* 测量按钮样式 */
        .measure-btn {
            background-color: #3498db;
            color: white;
        }
        
        .measure-btn:hover {
            background-color: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        /* 清除按钮样式 */
        .clear-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .clear-btn:hover {
            background-color: #c0392b;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }
        
        /* 测量信息样式 */
        .measure-info {
            background: white;
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            font-size: 14px;
            line-height: 1.6;
            color: #555;
            border-left: 3px solid #3498db;
        }
        
        /* 经纬度显示控件样式 */
        .leaflet-control-coordinates {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: 500;
            color: #333;
            text-align: left;
            border: 1px solid #ddd;
        }
        
        /* 响应式设计 */
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
                margin: 30px 0 20px;
            }
            
            #map {
                width: 95%;
                height: 65vh;
            }
            
            .measure-btn, .clear-btn {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .leaflet-control-coordinates {
                font-size: 12px;
                padding: 6px 10px;
            }
        }
    </style>
</head>
<body>
    <!-- 2. 创建标题 -->
    <h1>空中丝路高分中心</h1>
    <!-- 2.5 添加地图模式切换按钮 -->
    <div style="text-align: center; margin-bottom: 20px;">
        <button id="2d3dToggle" class="measure-btn" style="padding: 10px 30px; font-size: 16px;">
            切换到三维模式
        </button>
    </div>
    
    <!-- 3. 创建用于显示二维地图的div容器 -->
    <div id="map"></div>
    <!-- 3.1 创建用于显示三维地图的div容器 -->
    <div id="cesiumContainer" style="position: relative; height: 70vh; width: 90%; max-width: 1200px; margin: 0 auto 40px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); display: none; overflow: hidden;"></div>

    <!-- 4. 引入Leaflet的JavaScript库 -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        crossorigin=""></script>
    <!-- 引入Leaflet绘制插件 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <!-- 引入Cesium库 -->
    <link rel="stylesheet" href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>

    <script>
        // 5. 初始化地图并设置视图（中心点坐标和缩放级别）
        var map = L.map('map', {
            zoomControl: false,  // 隐藏缩放控件
            attributionControl: false,  // 隐藏版权信息
            scaleControl: false  // 隐藏比例尺
        }).setView([34.27, 108.95], 4);

        // 6. 添加底图图层
        // 第一个底图（卫星影像） - 使用可靠的在线瓦片服务
        var satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            maxZoom: 19,
            attribution: ''
        }).addTo(map);

        // 第二个底图（新添加的底图）
        var geovisLayer = L.tileLayer('https://tiles1.geovisearth.com/base/v1/img/{z}/{x}/{y}?format=webp&tmsIds=w&token=d2638fc2f7c3f79ab175f0daa7359adf7dd5188e58b834cd27893e3fc0dbcce2', {
            maxZoom: 19,
            attribution: ''
        });

        // 7. 定义坐标点数组（纬度，经度）
        var coordinates = [
            [23.36, 103.15],
            [30.27, 120.15],
            [37.78, 107.41],
            [33.58, 102.96],
            [38.25, 90.86],
            [35.76, 109.43],
            [41.78, 84.25],
            [37.43, 110.89],
            [31.40, 109.62],
            [27.81, 106.41],
            [26.82, 100.25],
            [28.55, 102.17],
            [33.37, 104.96],
            [29.33, 95.33],
            [32.52, 108.53],
            [34.48, 100.24],
            [37.88, 77.41],
            [30.29, 108.94],
            [35.58, 109.25],
            [34.14, 112.09],
            [28.57, 109.48],
            [39.60, 109.78],
            [36.60, 109.48],
            [37.51, 105.18],
            [37.78, 107.41],
            [29.53, 104.67],
            [30.05, 101.96],
            [31.48, 103.58],
            [36.41, 94.90],
            [37.59, 107.60],
            [32.31, 108.90],
            [44.17, 87.53],
            [37.13, 109.77]
        ];

        // 8. 为每个坐标点添加标记，创建标记图层组
        var markersLayer = L.layerGroup();
        var markers = [];
        
        for (var i = 0; i < coordinates.length; i++) {
            var marker = L.marker(coordinates[i]);
            markers.push(marker);
            markersLayer.addLayer(marker);
        }

        // 9. 将标记图层组添加到地图
        markersLayer.addTo(map);

        // 10. 调整地图视图以显示所有标记点
        if (markers.length > 0) {
            var group = L.featureGroup(markers);
            map.fitBounds(group.getBounds(), { padding: [50, 50] });
        }

        // 11. 添加图层控制，实现底图切换和标记点显示控制
        var baseMaps = {
            "卫星影像": satelliteLayer,
            "星图底图": geovisLayer
        };
        
        // 添加中国行政区划图层
        var chinaAdminLayer = L.layerGroup();
        
        var overlayMaps = {
            "项目标记": markersLayer,
            "中国行政区划": chinaAdminLayer
        };

        var layerControl = L.control.layers(baseMaps, overlayMaps, {
            collapsed: true,
            position: 'topright'
        }).addTo(map);
        
        // 重新使用可靠的中国行政区划GeoJSON数据源
        fetch('https://geo.datav.aliyun.com/areas_v3/bound/100000_full.json')
            .then(response => {
                if (!response.ok) {
                    throw new Error('网络响应失败: ' + response.status);
                }
                return response.json();
            })
            .then(data => {
                console.log('成功加载行政区划数据:', data);
                // 清空现有图层
                chinaAdminLayer.clearLayers();
                
                // 创建GeoJSON图层并添加到我们的图层组
                var geoLayer = L.geoJSON(data, {
                    style: function(feature) {
                        return {
                            color: '#2c3e50',  // 边界颜色
                            weight: 1,        // 边界宽度
                            opacity: 0.8,     // 边界透明度
                            fillColor: '#3498db',  // 填充颜色
                            fillOpacity: 0.2  // 填充透明度
                        };
                    },
                    onEachFeature: function(feature, layer) {
                        // 添加鼠标悬停事件
                        layer.on('mouseover', function() {
                            layer.setStyle({
                                fillOpacity: 0.4,
                                weight: 2
                            });
                        });
                        layer.on('mouseout', function() {
                            layer.setStyle({
                                fillOpacity: 0.2,
                                weight: 1
                            });
                        });
                        // 添加点击事件
                        layer.on('click', function() {
                            var infoDiv = document.getElementById('measure-info');
                            if (infoDiv) {
                                infoDiv.innerHTML = '行政区划: ' + feature.properties.name;
                            }
                        });
                    }
                });
                
                // 将GeoJSON图层添加到我们的图层组
                geoLayer.addTo(chinaAdminLayer);
                
                // 将行政区划图层添加到地图（默认显示）
                chinaAdminLayer.addTo(map);
                
                // 如果三维场景已经初始化，同步行政区划数据
                if (viewer && !is2DMode) {
                    // 清除之前的行政区划实体
                    cesiumAdminEntities.forEach(entity => {
                        viewer.entities.remove(entity);
                    });
                    cesiumAdminEntities = [];
                    
                    // 添加新的行政区划到Cesium
                    if (data && data.type === 'FeatureCollection') {
                        data.features.forEach(function(feature) {
                            if (feature.geometry && (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon')) {
                                var entities = createCesiumPolygons(feature.geometry, feature.properties);
                                cesiumAdminEntities = cesiumAdminEntities.concat(entities);
                            }
                        });
                    }
                }
            })
            .catch(error => {
                console.error('加载中国行政区划数据失败:', error);
            });

        // 11. 添加测量功能
        // 存储测量相关的变量
        var measureMode = false;
        var measureType = ''; // 'distance' or 'area'
        var measurePoints = [];
        var measureLine = null;
        var measurePolygon = null;
        var measureMarkerGroup = null;
        
        // 创建自定义测量控制面板
        var MeasureControl = L.Control.extend({
            options: {
                position: 'topleft'
            },
            
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'measure-control');
                
                // 创建距离测量按钮
                var distanceBtn = L.DomUtil.create('button', 'measure-btn', container);
                distanceBtn.innerHTML = '距离量测';
                distanceBtn.title = '点击开始距离测量';
                distanceBtn.id = 'distance-measure-btn';
                
                // 创建面积测量按钮
                var areaBtn = L.DomUtil.create('button', 'measure-btn', container);
                areaBtn.innerHTML = '面积量测';
                areaBtn.title = '点击开始面积测量';
                areaBtn.id = 'area-measure-btn';
                
                // 创建清除按钮（初始隐藏）
                var clearBtn = L.DomUtil.create('button', 'clear-btn', container);
                clearBtn.innerHTML = '清除测量';
                clearBtn.title = '清除所有测量结果';
                clearBtn.style.display = 'none'; // 初始隐藏
                
                // 测量信息显示区域（初始隐藏）
                var infoDiv = L.DomUtil.create('div', 'measure-info', container);
                infoDiv.id = 'measure-info';
                infoDiv.innerHTML = '点击"距离量测"或"面积量测"按钮开始测量';
                infoDiv.style.display = 'none'; // 初始隐藏
                
                // 距离测量按钮点击事件
                L.DomEvent.on(distanceBtn, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    
                    if (!measureMode) {
                        // 进入距离测量模式
                        measureMode = true;
                        measureType = 'distance';
                        distanceBtn.innerHTML = '结束测量';
                        areaBtn.disabled = true;
                        areaBtn.style.opacity = '0.5';
                        infoDiv.innerHTML = '距离测量模式已激活：<br>1. 点击地图选择起点<br>2. 点击地图选择多个点<br>3. 右击结束测量';
                    
                    // 显示清除按钮和信息显示区域
                    clearBtn.style.display = 'inline-block';
                    infoDiv.style.display = 'block';
                    
                    // 清除之前的测量结果
                    clearMeasurements();
                    
                    // 绑定地图点击事件和右键结束事件
                    map.on('click', onMapClickMeasure);
                    map.on('contextmenu', onMapRightClickEndMeasure);
                    // 禁用地图默认右键菜单和拖拽
                    L.DomEvent.on(map._container, 'contextmenu', L.DomEvent.stopPropagation);
                    map.dragging.disable();
                    
                    // 将鼠标样式变为手指
                    map._container.style.cursor = 'pointer';
                    } else if (measureType === 'distance') {
                        // 退出距离测量模式
                        exitMeasureMode();
                        distanceBtn.innerHTML = '距离量测';
                        areaBtn.disabled = false;
                        areaBtn.style.opacity = '1';
                        
                        // 如果没有完成测量，隐藏清除按钮
                        if (measurePoints.length < 2) {
                            clearBtn.style.display = 'none';
                            infoDiv.style.display = 'none';
                        }
                    }
                });
                
                // 面积测量按钮点击事件
                L.DomEvent.on(areaBtn, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    
                    if (!measureMode) {
                        // 进入面积测量模式
                        measureMode = true;
                        measureType = 'area';
                        areaBtn.innerHTML = '结束测量';
                        distanceBtn.disabled = true;
                        distanceBtn.style.opacity = '0.5';
                        infoDiv.innerHTML = '面积测量模式已激活：<br>1. 点击地图选择多个点（至少3个）<br>2. 右击结束测量并计算面积';
                        
                        // 显示清除按钮和信息显示区域
                        clearBtn.style.display = 'inline-block';
                        infoDiv.style.display = 'block';
                        
                        // 清除之前的测量结果
                        clearMeasurements();
                        
                        // 绑定地图点击事件
                        map.on('click', onMapClickMeasure);
                        // 绑定右键点击事件结束测量
                        map.on('contextmenu', onMapRightClickEndMeasure);
                        // 禁用地图默认右键菜单
                        map.dragging.disable();
                        
                        // 将鼠标样式变为手指
                        map._container.style.cursor = 'pointer';
                    } else if (measureType === 'area') {
                        // 退出面积测量模式
                        exitMeasureMode();
                        areaBtn.innerHTML = '面积量测';
                        distanceBtn.disabled = false;
                        distanceBtn.style.opacity = '1';
                        
                        // 如果没有完成测量，隐藏清除按钮
                        if (measurePoints.length < 3) {
                            clearBtn.style.display = 'none';
                            infoDiv.style.display = 'none';
                        }
                    }
                });
                
                // 清除按钮点击事件
                L.DomEvent.on(clearBtn, 'click', function(e) {
                    L.DomEvent.stopPropagation(e);
                    clearMeasurements();
                    infoDiv.innerHTML = '测量结果已清除<br>点击"距离量测"或"面积量测"按钮重新开始';
                    
                    // 清除后隐藏清除按钮
                    clearBtn.style.display = 'none';
                    
                    // 退出测量模式并重置按钮状态
                    exitMeasureMode();
                    
                    // 隐藏信息显示区域
                    infoDiv.style.display = 'none';
                });
                
                // 防止地图点击事件传播
                L.DomEvent.disableClickPropagation(container);
                
                return container;
            }
        });
        
        // 添加测量控件到地图
        map.addControl(new MeasureControl());
        
        // 地图点击事件处理函数（测量模式）
        function onMapClickMeasure(e) {
            if (!measureMode) return;
            
            // 阻止点击事件的传播，确保双击事件可以正常触发
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            
            // 添加测量点
            var point = e.latlng;
            measurePoints.push(point);
            
            // 创建点标记
            var marker = L.circleMarker(point, {
                color: 'red',
                radius: 5,
                fillOpacity: 0.8
            }).addTo(map);
            
            if (!measureMarkerGroup) {
                measureMarkerGroup = L.layerGroup().addTo(map);
            }
            measureMarkerGroup.addLayer(marker);
            
            if (measureType === 'distance') {
                // 距离测量
                if (measurePoints.length === 1) {
                    // 更新信息显示
                    var infoDiv = document.getElementById('measure-info');
                    infoDiv.innerHTML = '已选择起点<br>请点击地图选择更多点<br>右击结束测量';
                } else if (measurePoints.length > 1) {
                    // 移除之前的预览线
                    if (measureLine) {
                        map.removeLayer(measureLine);
                        measureLine = null;
                    }
                    
                    // 绘制折线预览
                    measureLine = L.polyline(measurePoints, {
                        color: 'blue',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(map);
                    measureMarkerGroup.addLayer(measureLine);
                    
                    // 计算并显示最新一段线段的距离
                    var currentIndex = measurePoints.length - 1;
                    var previousPoint = measurePoints[currentIndex - 1];
                    var currentPoint = measurePoints[currentIndex];
                    var segmentDistance = calculateDistance(previousPoint, currentPoint);
                    
                    // 在最新线段的中点添加距离标签
                    var segmentMidPoint = getMidPoint(previousPoint, currentPoint);
                    var segmentIconSize = [90, 20];
                    var segmentLabel = L.marker(segmentMidPoint, {
                        icon: L.divIcon({
                            className: 'distance-label',
                            html: '<div style="background: white; padding: 2px 6px; border-radius: 3px; border: 1px solid blue; font-size: 12px;">' + 
                                   (segmentDistance >= 1000 ? (segmentDistance / 1000).toFixed(2) + ' km' : 
                                   segmentDistance.toFixed(0) + ' m') + '</div>',
                            iconSize: segmentIconSize,
                            iconAnchor: [segmentIconSize[0]/2, 10]
                        })
                    }).addTo(map);
                    
                    measureMarkerGroup.addLayer(segmentLabel);
                    
                    // 更新信息显示，实时显示各段距离
                    var infoDiv = document.getElementById('measure-info');
                    var infoText = '已选择 ' + measurePoints.length + ' 个点<br>';
                    
                    // 计算总距离和各段距离
                    var totalDistance = 0;
                    for (var i = 0; i < measurePoints.length - 1; i++) {
                        var segDist = calculateDistance(measurePoints[i], measurePoints[i + 1]);
                        totalDistance += segDist;
                        infoText += '线段 ' + (i + 1) + ': ' + (segDist >= 1000 ? (segDist / 1000).toFixed(2) + ' 公里' : segDist.toFixed(0) + ' 米') + '<br>';
                    }
                    
                    infoText += '<br>右击结束测量并查看总距离';
                    infoDiv.innerHTML = infoText;
                }
            } else if (measureType === 'area') {
                // 面积测量
                // 如果已有一个点，开始绘制折线
                if (measurePoints.length === 1) {
                    // 更新信息显示
                    var infoDiv = document.getElementById('measure-info');
                    infoDiv.innerHTML = '已选择第一个点<br>继续点击地图选择更多点（至少3个）<br>右击完成测量';
                } else if (measurePoints.length > 1) {
                    // 移除之前的折线
                    if (measurePolygon) {
                        map.removeLayer(measurePolygon);
                        measurePolygon = null;
                    }
                    
                    // 绘制折线预览（不闭合）
                    measurePolygon = L.polyline(measurePoints, {
                        color: 'green',
                        weight: 3,
                        opacity: 0.7,
                        dashArray: '10, 10'
                    }).addTo(map);
                    measureMarkerGroup.addLayer(measurePolygon);
                    
                    // 更新信息显示
                    var infoDiv = document.getElementById('measure-info');
                    infoDiv.innerHTML = '已选择 ' + measurePoints.length + ' 个点<br>继续点击添加更多点或右击完成测量';
                }
            }
        }
        
        // 地图右键点击事件处理函数（结束测量模式）
        function onMapRightClickEndMeasure(e) {
            // 阻止默认右键菜单
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            
            if (!measureMode) return;
            
            if (measureType === 'distance') {
                // 结束距离测量
                if (measurePoints.length < 2) {
                    var infoDiv = document.getElementById('measure-info');
                    infoDiv.innerHTML = '至少需要2个点才能计算距离<br>请继续添加点或点击"清除测量"重新开始';
                    return;
                }
                
                // 计算总距离和各段距离（单位：米）
                var totalDistance = 0;
                var segmentDistances = [];
                
                // 仅计算总距离和各段距离，分段距离标签已在点击时实时创建
                for (var i = 0; i < measurePoints.length - 1; i++) {
                    var segmentDistance = calculateDistance(measurePoints[i], measurePoints[i + 1]);
                    segmentDistances.push(segmentDistance);
                    totalDistance += segmentDistance;
                }
                
                // 显示距离信息
                var infoDiv = document.getElementById('measure-info');
                var infoText = '测量完成！<br>';
                
                // 添加各段距离信息
                for (var j = 0; j < segmentDistances.length; j++) {
                    var segmentDistance = segmentDistances[j];
                    infoText += '线段 ' + (j + 1) + ': ' + (segmentDistance >= 1000 ? (segmentDistance / 1000).toFixed(2) + ' 公里' : segmentDistance.toFixed(0) + ' 米') + '<br>';
                }
                
                // 添加总距离信息
                if (totalDistance >= 1000) {
                    // 如果距离大于1公里，显示为公里
                    infoText += '总距离: ' + (totalDistance / 1000).toFixed(2) + ' 公里<br>' + 
                        '或 ' + totalDistance.toFixed(0) + ' 米';
                } else {
                    // 否则显示为米
                    infoText += '总距离: ' + totalDistance.toFixed(0) + ' 米';
                }
                
                infoDiv.innerHTML = infoText;
                
                // 在折线中间添加总距离标签
                var midPointIndex = Math.floor(measurePoints.length / 2);
                var midPoint = getMidPoint(measurePoints[midPointIndex - 1], measurePoints[midPointIndex]);
                
                // 如果只有两个点，总距离标签显示在中点
                // 如果有多个点，总距离标签显示在中点的上方（避免与分段标签重叠）
                var iconAnchorY = 10;
                if (measurePoints.length > 2) {
                    // 进一步调整总距离标签的位置，使其显示在折线上方更远的位置
                    iconAnchorY = -20;
                    // 对于总距离标签，使用更大的垂直偏移
                    midPoint = L.latLng(
                        midPoint.lat + 0.0001, // 向北偏移一点
                        midPoint.lng
                    );
                }
                
                var totalDistanceLabel = L.marker(midPoint, {
                    icon: L.divIcon({
                        className: 'distance-label',
                        html: '<div style="background: white; padding: 2px 6px; border-radius: 3px; border: 1px solid blue; font-size: 12px; font-weight: bold;">' + 
                               (totalDistance >= 1000 ? (totalDistance / 1000).toFixed(2) + ' km (总)' : 
                               totalDistance.toFixed(0) + ' m (总)') + '</div>',
                        iconSize: [90, 20],
                        iconAnchor: [45, iconAnchorY]
                    })
                }).addTo(map);
                
                measureMarkerGroup.addLayer(totalDistanceLabel);
            } else if (measureType === 'area') {
                // 结束面积测量
                if (measurePoints.length < 3) {
                    var infoDiv = document.getElementById('measure-info');
                    infoDiv.innerHTML = '至少需要3个点才能计算面积<br>请继续添加点或点击"清除测量"重新开始';
                    return;
                }
                
                // 移除预览多边形
                if (measurePolygon) {
                    map.removeLayer(measurePolygon);
                    measurePolygon = null;
                }
                
                // 绘制完整的多边形（包括最后一个点和第一个点连接）
                measurePolygon = L.polygon(measurePoints, {
                    color: 'green',
                    weight: 3,
                    opacity: 0.7,
                    fillColor: 'green',
                    fillOpacity: 0.2
                }).addTo(map);
                measureMarkerGroup.addLayer(measurePolygon);
                
                // 计算面积（单位：平方米）
                var area = calculateArea(measurePoints);
                
                // 显示面积信息
                var infoDiv = document.getElementById('measure-info');
                if (area >= 1000000) {
                    // 如果面积大于1平方公里，显示为平方公里
                    infoDiv.innerHTML = '测量完成！<br>面积: ' + (area / 1000000).toFixed(2) + ' 平方公里';
                } else if (area >= 10000) {
                    // 如果面积大于1公顷，显示为公顷
                    infoDiv.innerHTML = '测量完成！<br>面积: ' + (area / 10000).toFixed(2) + ' 公顷';
                } else {
                    // 否则显示为平方米
                    infoDiv.innerHTML = '测量完成！<br>面积: ' + area.toFixed(0) + ' 平方米';
                }
                
                // 在多边形中心添加面积标签
                var centerPoint = calculatePolygonCenter(measurePoints);
                var areaLabel = L.marker(centerPoint, {
                    icon: L.divIcon({
                        className: 'area-label',
                        html: '<div style="background: white; padding: 2px 6px; border-radius: 3px; border: 1px solid green; font-size: 12px;">' + 
                               (area >= 1000000 ? (area / 1000000).toFixed(2) + ' km²' : 
                               (area >= 10000 ? (area / 10000).toFixed(2) + ' 公顷' : 
                               area.toFixed(0) + ' m²')) + '</div>',
                        iconSize: [80, 20],
                        iconAnchor: [40, 10]
                    })
                }).addTo(map);
                
                measureMarkerGroup.addLayer(areaLabel);
            }
            
            // 退出测量模式
            exitMeasureMode();
        }
        
        // 计算两点之间的距离（使用Haversine公式）
        function calculateDistance(point1, point2) {
            var R = 6371000; // 地球半径（米）
            var lat1 = point1.lat * Math.PI / 180;
            var lat2 = point2.lat * Math.PI / 180;
            var dLat = (point2.lat - point1.lat) * Math.PI / 180;
            var dLng = (point2.lng - point1.lng) * Math.PI / 180;
            
            var a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1) * Math.cos(lat2) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            
            return R * c;
        }
        
        // 获取两点之间的中点
        function getMidPoint(point1, point2) {
            return L.latLng(
                (point1.lat + point2.lat) / 2,
                (point1.lng + point2.lng) / 2
            );
        }
        
        // 清除所有测量结果
        function clearMeasurements() {
            measurePoints = [];
            
            if (measureLine) {
                map.removeLayer(measureLine);
                measureLine = null;
            }
            
            if (measurePolygon) {
                map.removeLayer(measurePolygon);
                measurePolygon = null;
            }
            
            if (measureMarkerGroup) {
                map.removeLayer(measureMarkerGroup);
                measureMarkerGroup = null;
            }
        }
        
        // 退出测量模式
        function exitMeasureMode() {
            // 重置测量模式
            measureMode = false;
            measureType = null;
            measurePoints = [];
            
            // 解绑事件
            map.off('click', onMapClickMeasure);
            map.off('contextmenu', onMapRightClickEndMeasure);
            L.DomEvent.off(map._container, 'contextmenu', L.DomEvent.stopPropagation);
            
            // 恢复地图默认鼠标样式
            map._container.style.cursor = '';
            
            // 恢复地图拖拽功能
            map.dragging.enable();
            
            // 重置按钮状态
            var distanceBtn = document.getElementById('distance-measure-btn');
            var areaBtn = document.getElementById('area-measure-btn');
            if (distanceBtn) {
                distanceBtn.innerHTML = '距离量测';
                distanceBtn.disabled = false;
                distanceBtn.style.opacity = '1';
            }
            if (areaBtn) {
                areaBtn.innerHTML = '面积量测';
                areaBtn.disabled = false;
                areaBtn.style.opacity = '1';
            }
            
            var infoDiv = document.getElementById('measure-info');
            var clearBtn = document.querySelector('.clear-btn');
            
            if (measurePoints.length < 2) {
                // 如果没有完成测量，重置显示
                if (infoDiv) {
                    infoDiv.innerHTML = '测量已取消<br>点击"距离量测"或"面积量测"按钮重新开始';
                }
            } else if (measureType === 'distance') {
                // 如果已完成距离测量，显示测量结果
                if (infoDiv) {
                    infoDiv.innerHTML = '测量完成！<br>距离: ' + 
                        (calculateDistance(measurePoints[0], measurePoints[1]) / 1000).toFixed(2) + ' 公里<br>' + 
                        '点击"距离量测"按钮重新开始<br>点击"清除测量"清除结果';
                }
            } else if (measureType === 'area' && measurePoints.length >= 3) {
                // 如果已完成面积测量，显示测量结果
                if (infoDiv) {
                    var area = calculateArea(measurePoints);
                    if (area >= 1000000) {
                        // 如果面积大于1平方公里，显示为平方公里
                        infoDiv.innerHTML = '测量完成！<br>面积: ' + (area / 1000000).toFixed(2) + ' 平方公里<br>' +
                            '点击"面积量测"按钮重新开始<br>点击"清除测量"清除结果';
                    } else if (area >= 10000) {
                        // 如果面积大于1公顷，显示为公顷
                        infoDiv.innerHTML = '测量完成！<br>面积: ' + (area / 10000).toFixed(2) + ' 公顷<br>' +
                            '点击"面积量测"按钮重新开始<br>点击"清除测量"清除结果';
                    } else {
                        // 否则显示为平方米
                        infoDiv.innerHTML = '测量完成！<br>面积: ' + area.toFixed(0) + ' 平方米<br>' +
                            '点击"面积量测"按钮重新开始<br>点击"清除测量"清除结果';
                    }
                }
            }
        }
        
        // 监听键盘事件，按ESC键退出测量模式
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && measureMode) {
                exitMeasureMode();
                var infoDiv = document.getElementById('measure-info');
                if (infoDiv) {
                    infoDiv.innerHTML = '测量已取消 (按ESC键退出)<br>点击"距离量测"或"面积量测"按钮重新开始';
                }
            }
        });
        
        // 计算多边形面积（使用Shoelace公式）
        function calculateArea(points) {
            if (points.length < 3) return 0;
            
            var area = 0;
            var R = 6371000; // 地球半径（米）
            
            for (var i = 0; i < points.length; i++) {
                var j = (i + 1) % points.length;
                var lat1 = points[i].lat * Math.PI / 180;
                var lon1 = points[i].lng * Math.PI / 180;
                var lat2 = points[j].lat * Math.PI / 180;
                var lon2 = points[j].lng * Math.PI / 180;
                
                area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
            }
            
            area = Math.abs(area) * R * R / 2;
            return area;
        }
        
        // 计算多边形中心点
        function calculatePolygonCenter(points) {
            if (points.length === 0) return null;
            
            var latSum = 0;
            var lngSum = 0;
            
            for (var i = 0; i < points.length; i++) {
                latSum += points[i].lat;
                lngSum += points[i].lng;
            }
            
            return L.latLng(latSum / points.length, lngSum / points.length);
        }
        
        // 12. 添加经纬度显示控件
        // 创建一个简单的div元素来显示经纬度
        var coordsDiv = document.createElement('div');
        coordsDiv.id = 'coordinates-display';
        coordsDiv.className = 'leaflet-control leaflet-control-coordinates';
        coordsDiv.innerHTML = '经度: --, 纬度: --';
        
        // 直接将div添加到地图的控件容器中
        var mapControlsContainer = document.querySelector('.leaflet-bottom.leaflet-right');
        if (mapControlsContainer) {
            mapControlsContainer.appendChild(coordsDiv);
        } else {
            // 如果找不到控件容器，将div添加到地图容器中
            var mapContainer = document.getElementById('map');
            mapContainer.appendChild(coordsDiv);
        }
        
        // 监听地图鼠标移动事件
        map.on('mousemove', function(e) {
            var lat = e.latlng.lat.toFixed(4);
            var lng = e.latlng.lng.toFixed(4);
            coordsDiv.innerHTML = '经度: ' + lng + ', 纬度: ' + lat;
        });
        
        // 鼠标离开地图时重置显示
        map.on('mouseout', function() {
            coordsDiv.innerHTML = '经度: --, 纬度: --';
        });

        // 13. 添加三维地球功能
        // 初始化Cesium Viewer实例
        var viewer;
        var is2DMode = true;
        var cesiumMarkers = [];
        var cesiumAdminEntities = [];

        // 初始化Cesium Viewer
        function initCesium() {
            try {
                console.log('开始初始化Cesium...');
                
                // 1. 处理localStorage访问问题
                if (typeof localStorage !== 'undefined') {
                    try {
                        // 测试localStorage访问
                        localStorage.getItem('cesium-test');
                    } catch (e) {
                        console.warn('localStorage访问受限，将禁用Cesium的localStorage使用');
                        
                        // 创建一个模拟的localStorage对象
                        var mockStorage = {
                            data: {},
                            getItem: function(key) {
                                return this.data[key] || null;
                            },
                            setItem: function(key, value) {
                                this.data[key] = value;
                            },
                            removeItem: function(key) {
                                delete this.data[key];
                            },
                            clear: function() {
                                this.data = {};
                            },
                            length: 0,
                            key: function(index) {
                                return Object.keys(this.data)[index] || null;
                            }
                        };
                        
                        // 尝试安全地替换localStorage
                        try {
                            Object.defineProperty(window, 'localStorage', {
                                value: mockStorage,
                                writable: true,
                                configurable: true
                            });
                        } catch (defineError) {
                            // 如果无法定义，就直接赋值
                            window.localStorage = mockStorage;
                        }
                    }
                }
                
                // 2. 检查WebGL支持
                function checkWebGLSupport() {
                    try {
                        var canvas = document.createElement('canvas');
                        
                        // 检查WebGL渲染上下文
                        var glOptions = {
                            alpha: false,
                            depth: true,
                            stencil: true,
                            antialias: true,
                            premultipliedAlpha: false,
                            preserveDrawingBuffer: false,
                            failIfMajorPerformanceCaveat: false
                        };
                        
                        var gl = canvas.getContext('webgl', glOptions) || canvas.getContext('experimental-webgl', glOptions);
                        
                        if (gl) {
                            // 测试基本WebGL功能
                            var shaderProgram = gl.createProgram();
                            if (shaderProgram) {
                                gl.deleteProgram(shaderProgram);
                                return true;
                            }
                        }
                    } catch (e) {
                        console.error('WebGL检测失败:', e);
                    }
                    return false;
                }
                
                if (!checkWebGLSupport()) {
                    throw new Error('当前浏览器不支持WebGL，无法运行Cesium');
                }
                
                console.log('浏览器支持WebGL');
                
                // 3. 禁用所有Ion相关功能和网络请求
                Cesium.Ion.defaultAccessToken = '';
                Cesium.IonResource.defaultAccessToken = '';
                
                // 禁用Ion服务器
                Cesium.Ion.defaultServer = '';
                Cesium.IonResource.defaultServer = '';
                
                // 4. 使用最基础的配置初始化Cesium Viewer
                var container = document.getElementById('cesiumContainer');
                if (!container) {
                    throw new Error('Cesium容器不存在');
                }
                
                // 确保容器有正确的尺寸
                container.style.width = container.style.width || '100%';
                container.style.height = container.style.height || '100%';
                
                // 5. 创建最小化配置的Viewer
                viewer = new Cesium.Viewer(container, {
                    // 禁用所有控件
                    animation: false,
                    timeline: false,
                    geocoder: false,
                    homeButton: false,
                    infoBox: false,
                    baseLayerPicker: false,
                    navigationHelpButton: false,
                    sceneModePicker: false,
                    fullscreenButton: false,
                    projectionPicker: false,
                    
                    // 禁用所有网络相关功能
                    imageryProvider: false,
                    terrainProvider: false,
                    
                    // 禁用天空和大气效果
                    skyBox: false,
                    skyAtmosphere: false,
                    
                    // 禁用光照
                    sun: false,
                    moon: false,
                    stars: false,
                    
                    // 禁用雾效
                    fog: false,
                    
                    // 配置地球
                    globe: {
                        show: true,
                        baseColor: Cesium.Color.BLUE,
                        enableLighting: false,
                        depthTestAgainstTerrain: false,
                        // 设置最小最大高度
                        minimumTerrainHeight: -11000,
                        maximumTerrainHeight: 8850
                    },
                    
                    // 禁用渲染循环，我们将手动控制
                    useDefaultRenderLoop: true,
                    
                    // 禁用各种自动功能
                    requestRenderMode: false,
                    
                    // 设置渲染帧率限制
                    targetFrameRate: 30,
                    
                    // 禁用性能监控
                    showRenderLoopErrors: false,
                    
                    // 禁用数据源
                    dataSources: new Cesium.DataSourceCollection()
                });
                
                console.log('Cesium Viewer创建成功');
                
                // 6. 配置场景
                var scene = viewer.scene;
                if (scene) {
                    // 禁用各种特效
                    scene.fog.enabled = false;
                    scene.globe.enableLighting = false;
                    scene.skyAtmosphere.show = false;
                    scene.sun.show = false;
                    scene.moon.show = false;
                    scene.stars.show = false;
                    
                    // 确保场景使用正确的渲染上下文
                    if (scene.context) {
                        console.log('WebGL上下文已初始化');
                    }
                }
                
                // 7. 设置相机位置
                if (viewer.camera) {
                    try {
                        // 使用固定位置确保能看到地球
                        var initialPosition = Cesium.Cartesian3.fromDegrees(105.0, 35.0, 10000000.0);
                        var initialOrientation = {
                            heading: 0.0,
                            pitch: -Cesium.Math.PI_OVER_TWO,
                            roll: 0.0
                        };
                        
                        viewer.camera.setView({
                            destination: initialPosition,
                            orientation: initialOrientation
                        });
                        
                        console.log('相机位置已设置');
                    } catch (cameraError) {
                        console.error('设置相机位置失败:', cameraError);
                    }
                }
                
                // 8. 强制渲染
                if (scene && typeof scene.requestRender === 'function') {
                    scene.requestRender();
                    console.log('请求场景渲染');
                }
                
                console.log('Cesium初始化完成');
                
            } catch (error) {
                console.error('Cesium初始化失败:', error);
                
                // 更友好的错误提示
                var errorMessage = 'Cesium初始化失败: ' + error.message;
                if (error.message.indexOf('WebGL') !== -1) {
                    errorMessage += '\n\n建议尝试以下解决方案:\n1. 确保浏览器支持WebGL\n2. 检查显卡驱动是否为最新版本\n3. 尝试使用Chrome或Firefox浏览器\n4. 确保浏览器没有禁用硬件加速';
                }
                
                alert(errorMessage);
            }
        }
        
        // 在Cesium中创建多边形
        function createCesiumPolygons(geometry, properties) {
            var entities = [];
            var coordinates;
            
            if (geometry.type === 'Polygon') {
                coordinates = [geometry.coordinates];
            } else if (geometry.type === 'MultiPolygon') {
                coordinates = geometry.coordinates;
            }
            
            coordinates.forEach(function(polygonCoords) {
                // 外部环
                var outerRing = polygonCoords[0];
                
                // 转换为Cesium的Cartesian3坐标
                var positions = outerRing.map(function(coord) {
                    return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0);
                });
                
                // 创建多边形实体
                var entity = viewer.entities.add({
                    polygon: {
                        hierarchy: new Cesium.PolygonHierarchy(positions),
                        material: Cesium.Color.BLUE.withAlpha(0.2),
                        outline: true,
                        outlineColor: Cesium.Color.DARKBLUE,
                        outlineWidth: 1
                    },
                    name: properties.name
                });
                
                entities.push(entity);
                
                // 添加内部环（如果有）
                for (var i = 1; i < polygonCoords.length; i++) {
                    var innerRing = polygonCoords[i];
                    var innerPositions = innerRing.map(function(coord) {
                        return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], 0);
                    });
                    
                    entity.polygon.hierarchy.holes.push(new Cesium.PolygonHierarchy(innerPositions));
                }
            });
            
            return entities;
        }
        
        // 切换2D/3D模式的事件处理
        document.getElementById('2d3dToggle').addEventListener('click', function() {
            var toggleBtn = this;
            
            try {
                if (is2DMode) {
                    // 切换到三维模式
                    is2DMode = false;
                    toggleBtn.innerHTML = '切换到二维模式';
                    
                    // 检查Cesium库是否已加载
                    if (typeof Cesium === 'undefined') {
                        alert('Cesium库加载失败，请刷新页面重试');
                        return;
                    }
                    
                    // 隐藏二维地图，显示三维容器
                    var mapDiv = document.getElementById('map');
                    var cesiumDiv = document.getElementById('cesiumContainer');
                    
                    if (mapDiv && cesiumDiv) {
                        mapDiv.style.display = 'none';
                        cesiumDiv.style.display = 'block';
                        
                        console.log('三维容器已显示，尺寸:', cesiumDiv.getBoundingClientRect());
                        
                        // 初始化Cesium的核心函数
                        function initAndConfigureCesium() {
                            if (!viewer) {
                                console.log('开始初始化Cesium...');
                                try {
                                    initCesium();
                                } catch (initError) {
                                    console.error('Cesium初始化失败:', initError);
                                    return;
                                }
                            }
                            
                            // 确保viewer对象完全可用
                            if (viewer && typeof viewer === 'object' && viewer.camera && viewer.scene) {
                                console.log('Cesium Viewer已就绪');
                                
                                // 确保容器尺寸正确
                                if (typeof viewer.resize === 'function') {
                                    viewer.resize();
                                }
                                
                                // 设置相机位置，确保能看到地球
                                try {
                                    // 使用默认坐标或从二维地图获取
                                    var lng = 105.0;
                                    var lat = 35.0;
                                    
                                    // 检查map对象是否存在且有getCenter方法
                                    if (typeof map === 'object' && map !== null && typeof map.getCenter === 'function') {
                                        try {
                                            var center = map.getCenter();
                                            if (center && center.lng && center.lat) {
                                                lng = center.lng;
                                                lat = center.lat;
                                            }
                                        } catch (mapError) {
                                            console.warn('获取地图中心失败，使用默认坐标:', mapError);
                                        }
                                    }
                                    
                                    // 使用固定高度确保能看到地球
                                    var height = 10000000; // 10,000公里高度
                                     
                                    viewer.camera.setView({
                                        destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),
                                        orientation: {
                                            heading: 0.0,
                                            pitch: -Cesium.Math.PI_OVER_TWO,
                                            roll: 0.0
                                        }
                                    });
                                    console.log('Cesium相机位置已设置');
                                     
                                    // 强制渲染
                                    if (typeof viewer.scene.requestRender === 'function') {
                                        viewer.scene.requestRender();
                                    }
                                } catch (cameraError) {
                                    console.error('设置相机位置失败:', cameraError);
                                }
                            }
                        }
                        
                        // 等待容器完全可见后再初始化
                        setTimeout(initAndConfigureCesium, 200);
                    }
                    
                } else {
                    // 切换到二维模式
                    is2DMode = true;
                    toggleBtn.innerHTML = '切换到三维模式';
                    
                    // 隐藏三维容器，显示二维地图
                    var mapDiv = document.getElementById('map');
                    var cesiumDiv = document.getElementById('cesiumContainer');
                    
                    if (mapDiv && cesiumDiv) {
                        cesiumDiv.style.display = 'none';
                        mapDiv.style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('模式切换失败:', error);
                alert('切换模式失败: ' + error.message);
            }
        });
        
        // 监听行政区划图层的显示状态变化
        layerControl.getContainer().addEventListener('change', function(e) {
            if (e.target.type === 'checkbox' && e.target.id.includes('中国行政区划')) {
                if (viewer && !is2DMode) {
                    var isVisible = e.target.checked;
                    cesiumAdminEntities.forEach(entity => {
                        entity.show = isVisible;
                    });
                }
            }
        });
    </script>
</body>
</html>